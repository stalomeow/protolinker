package app

import (
	"flag"
	"fmt"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
	"path"
	"strings"
)

type CSharpGenerator struct {
	version string

	baseNamespace           string
	hasBaseNamespace        bool
	ctx                     *GenContext
	netMsgInterfaceFullName string
}

func NewCSharpGenerator(version string) *CSharpGenerator {
	return &CSharpGenerator{version: version}
}

func (g *CSharpGenerator) initGen(req *pluginpb.CodeGeneratorRequest) error {
	var configFile string
	flags := &flag.FlagSet{}
	flags.StringVar(&configFile, "config", "", "")
	flags.StringVar(&g.baseNamespace, "base_namespace", "", "")

	rawArgs, err := SetCommandLineFlags(req, flags)
	if err != nil {
		return err
	}

	_, g.hasBaseNamespace = rawArgs["base_namespace"]
	g.ctx, err = NewGenContextFromConfigFile(configFile)
	if err != nil {
		return err
	}

	g.netMsgInterfaceFullName = "INetMessage"
	if namespace := g.ctx.Config.Out.CSharp.Namespace; namespace != "" {
		g.netMsgInterfaceFullName = namespace + "." + g.netMsgInterfaceFullName
	}
	return nil
}

func (g *CSharpGenerator) Execute(req *pluginpb.CodeGeneratorRequest) (*pluginpb.CodeGeneratorResponse, error) {
	err := g.initGen(req)
	if err != nil {
		return nil, err
	}

	files, err := GetFilesToGenerate(req)
	if err != nil {
		return nil, err
	}

	rsp := new(pluginpb.CodeGeneratorResponse)
	allMsgTypeFullNames := make([]string, 0)

	for _, f := range files {
		genFile := &GenFile{}
		g.writeFileHeader(f, genFile)

		ns := getCSharpFileNamespace(f)
		if ns != "" {
			genFile.P("namespace ", ns)
			genFile.P("{")
			genFile.Indent(1)
		}

		msgNamesInFile, err := g.writeFlatMsg(f.Messages(), genFile)
		if err != nil {
			return nil, err
		}
		if len(msgNamesInFile) <= 0 {
			continue
		}

		for _, msgName := range msgNamesInFile {
			if ns != "" {
				msgName = ns + "." + msgName
			}
			allMsgTypeFullNames = append(allMsgTypeFullNames, msgName)
		}

		if ns != "" {
			genFile.Indent(-1)
			genFile.P("}")
		}

		filename, err := g.convertToCSharpFileNameWithoutExt(ns, f.Path())
		if err != nil {
			return nil, err
		}
		genFile.AppendToRsp(rsp, filename+".link.cs")
	}

	err = g.genLinkFile(allMsgTypeFullNames, rsp)
	return rsp, err
}

func (g *CSharpGenerator) writeFileHeader(srcFile protoreflect.FileDescriptor, genFile *GenFile) {
	genFile.P("// <auto-generated>")
	genFile.P("//     Generated by protoc-gen-cslink v", g.version, ".  DO NOT EDIT!")
	if srcFile != nil {
		genFile.P("//     source: ", srcFile.Path())
	}
	genFile.P("// </auto-generated>")
	genFile.P()
}

func (g *CSharpGenerator) writeFlatMsg(messages protoreflect.MessageDescriptors, genFile *GenFile) ([]string, error) {
	allMsgTypeNames := make([]string, 0)
	hierarchy := make([]string, 0)
	stack := make([]protoreflect.MessageDescriptor, 0)
	for i := messages.Len() - 1; i >= 0; i-- {
		stack = append(stack, nil, messages.Get(i))
	}

	// DFS
	for len(stack) > 0 {
		msg := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if msg == nil {
			hierarchy = hierarchy[:len(hierarchy)-1]
			continue
		}
		hierarchy = append(hierarchy, string(msg.Name()))
		if nestedMessages := msg.Messages(); nestedMessages.Len() > 0 {
			for i := nestedMessages.Len() - 1; i >= 0; i-- {
				stack = append(stack, nil, nestedMessages.Get(i))
			}
		}

		msgId, ok, err := g.ctx.AllocMsgId(GetLeadingComments(msg))
		if err != nil {
			return nil, err
		}
		if !ok {
			continue
		}

		msgName := hierarchy[len(hierarchy)-1]
		allMsgTypeNames = append(allMsgTypeNames, strings.Join(hierarchy, ".Types."))

		for _, parentMsg := range hierarchy[:len(hierarchy)-1] {
			genFile.P("partial class ", parentMsg)
			genFile.P("{")
			genFile.Indent(1)
			genFile.P("partial class Types")
			genFile.P("{")
			genFile.Indent(1)
		}

		genFile.P("partial class ", msgName, " : ", g.netMsgInterfaceFullName)
		genFile.P("{")
		genFile.Indent(1)
		genFile.P("public const ushort MsgId = ", msgId, ";")
		genFile.P("ushort ", g.netMsgInterfaceFullName, ".MsgId { get { return MsgId; } }")
		genFile.P()
		genFile.P("public const string MsgName = \"", msgName, "\";")
		genFile.P("string ", g.netMsgInterfaceFullName, ".MsgName { get { return MsgName; } }")
		genFile.Indent(-1)
		genFile.P("}")

		for i := 0; i < len(hierarchy)-1; i++ {
			genFile.Indent(-1)
			genFile.P("}")
			genFile.Indent(-1)
			genFile.P("}")
		}
	}
	return allMsgTypeNames, nil
}

func (g *CSharpGenerator) genLinkFile(allMsgTypeFullNames []string, rsp *pluginpb.CodeGeneratorResponse) error {
	if len(allMsgTypeFullNames) <= 0 {
		return nil
	}

	genFile := &GenFile{}
	g.writeFileHeader(nil, genFile)
	genFile.P("using pb = global::Google.Protobuf;")
	genFile.P()

	className := g.ctx.Config.Out.CSharp.ClassName
	namespace := g.ctx.Config.Out.CSharp.Namespace

	if namespace != "" {
		genFile.P("namespace ", namespace)
		genFile.P("{")
		genFile.Indent(1)
	}

	// INetMessage 接口
	if g.ctx.Config.Out.CSharp.IsMsgDisposable {
		genFile.P("public interface INetMessage : pb::IMessage, System.IDisposable")
	} else {
		genFile.P("public interface INetMessage : pb::IMessage")
	}
	genFile.P("{")
	genFile.Indent(1)
	genFile.P("ushort MsgId { get; }")
	genFile.P("string MsgName { get; }")
	genFile.Indent(-1)
	genFile.P("}")
	genFile.P()

	// The link class
	genFile.P("public partial class ", className)
	genFile.P("{")
	genFile.Indent(1)

	genFile.P("protected class MsgInfo")
	genFile.P("{")
	genFile.Indent(1)
	genFile.P("public string Name;")
	genFile.P("public pb::MessageParser Parser;")
	genFile.Indent(-1)
	genFile.P("}")
	genFile.P()

	genFile.P("protected readonly System.Collections.Generic.Dictionary<ushort, MsgInfo> MsgInfoMap;")
	genFile.P()

	// 构造方法
	genFile.P("public ", className, "()")
	genFile.P("{")
	genFile.Indent(1)
	genFile.P("this.MsgInfoMap = new()")
	genFile.P("{")
	genFile.Indent(1)
	for _, t := range allMsgTypeFullNames {
		genFile.P("[", t, ".MsgId] = new() { Name = ", t, ".MsgName, Parser = ", t, ".Parser },")
	}
	genFile.Indent(-1)
	genFile.P("};")
	genFile.Indent(-1)
	genFile.P("}")
	genFile.P()

	genFile.P("public pb::MessageParser GetMsgParserById(ushort msgId)")
	genFile.P("{")
	genFile.Indent(1)
	genFile.P("return this.MsgInfoMap.TryGetValue(msgId, out var msgInfo) ? msgInfo.Parser : default;")
	genFile.Indent(-1)
	genFile.P("}")
	genFile.P()

	genFile.P("public string GetMsgName(ushort msgId)")
	genFile.P("{")
	genFile.Indent(1)
	genFile.P("return this.MsgInfoMap.TryGetValue(msgId, out var msgInfo) ? msgInfo.Name : default;")
	genFile.Indent(-1)
	genFile.P("}")
	genFile.P()

	// Group 信息
	for _, group := range g.ctx.Config.MsgGroups {
		groupNameIdent := UnderscoresToCamelCase(group.Name, true, false)
		genFile.P("public const ushort MsgGroupMin_", groupNameIdent, " = ", group.Min, ";")
		genFile.P("public const ushort MsgGroupMax_", groupNameIdent, " = ", group.Max, ";")
	}

	genFile.Indent(-1)
	genFile.P("}")

	if namespace != "" {
		genFile.Indent(-1)
		genFile.P("}")
	}

	genFile.AppendToRsp(rsp, g.ctx.Config.Out.CSharp.Filename)
	return nil
}

func (g *CSharpGenerator) convertToCSharpFileNameWithoutExt(ns string, filename string) (string, error) {
	filename = strings.TrimSuffix(path.Base(filename), path.Ext(filename))
	filename = UnderscoresToCamelCase(filename, true, true)

	if !g.hasBaseNamespace {
		return filename, nil
	}

	nsSuffix := ns

	if g.baseNamespace != "" {
		// Check that the base_namespace is either equal to or a leading part of
		// the file namespace. This isn't just a simple prefix; "Foo.B" shouldn't
		// be regarded as a prefix of "Foo.Bar". The simplest option is to add "."
		// to both.
		suffix, found := strings.CutPrefix(ns, g.baseNamespace)
		if !found || (suffix != "" && !strings.HasPrefix(suffix, ".")) {
			return "", fmt.Errorf("namespace %s does not have base namespace %s", ns, g.baseNamespace)
		}

		if suffix == "" {
			nsSuffix = suffix
		} else {
			nsSuffix = suffix[1:] // trim leading period
		}
	}

	return path.Join(strings.ReplaceAll(nsSuffix, ".", "/"), filename), nil
}

func getCSharpFileNamespace(desc protoreflect.FileDescriptor) string {
	options := desc.Options().ProtoReflect()
	fields := options.Descriptor().Fields()
	for i := 0; i < fields.Len(); i++ {
		f := fields.Get(i)
		if f.Name() == "csharp_namespace" {
			if ns := options.Get(f).String(); ns != "" {
				return ns
			}
		}
	}
	return UnderscoresToCamelCase(string(desc.Package()), true, true)
}
